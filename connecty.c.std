/*
** Created by JLSS YACC 2.14 (2007-04-10 04:39:44)
** Source file: connecty.y
*/

#define YYJLSSYACC 1


/* Start of user defined code */
#line 2 "connecty.y"
/*
@(#)File:           $RCSfile: connecty.c.std,v $
@(#)Version:        $Revision: 2012.1 $
@(#)Last changed:   $Date: 2012/08/05 18:33:54 $
@(#)Purpose:        Grammar for SQLCMD statements
@(#)Author:         J Leffler
@(#)Copyright:      (C) JLSS 1998-2010,2012
@(#)Product:        SQLCMD Version 90.02 (2016-07-28)
*/

/*TABSTOP=4*/

/*
** This grammar recognizes CONNECT, SET CONNECTION, DISCONNECT,
** INFO, LOAD, UNLOAD and RELOAD statements.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "context.h"
#include "esqlutil.h"
#include "internal.h"
#include "jlss.h"
#include "connect.h"
#include "stderr.h"
#include "sqltoken.h"
#include "strdotfill.h"
#include "emalloc.h"

#ifndef DO_NOT_USE_JLSSYACC_DEFINES
/*
** If you are using JLSSYACC, these defines hide all the YACC symbols which
** are normally visible (see connecty.c.std).  These defines do not normally
** cause problems with a standard version of YACC.  If they do cause you
** problems, add -DDO_NOT_USE_JLSSYACC_DEFINES to the C compiler command
** line to remove them, and let Jonathan Leffler know which version of YACC
** you are using, and which platform you are using it on.
*/
#define YYERROR_UNUSED
#define YYBACKUP_UNUSED
#define YY_SC_PARSE     static
#define YY_SC_LEX       static
#define YY_SC_SYNTAX    static
#define YYGLOBAL        static
#define YYSTATIC        static
#else
#define YYSTATIC        extern
#endif /* DO_NOT_USE_JLSSYACC_DEFINES */

/*
** BISON only defines yydebug if YYDEBUG is set.
** BYACC defines yydebug unconditionally.
** JLSSYACC defines yydebug unless explicitly suppressed with YYDEBUG_UNUSED.
** Unix YACC defines yydebug unconditionally.
*/
#ifndef YYDEBUGVAR
#define YYDEBUGVAR yydebug
#endif
#if YYBISON && !YYDEBUG
int YYDEBUGVAR = 0;
#endif

struct Token
{
    int      toktype;
    char    *start;
    char    *end;
};
typedef struct Token Token;

#define YYSTYPE Token

static StmtType stmt_type;
static ConnInfo *conn;
static InfoInfo *info;
static LoadInfo *load;
static const char *c_token;     /* Where to start next token search */

static void set_connection(ConnInfo *c, const char *s, const char *e);
static void set_database(ConnInfo *c, const char *s, const char *e);
static void set_password(ConnInfo *c, const char *s, const char *e);
static void set_username(ConnInfo *c, const char *s, const char *e);
static void set_string(const char *type, char *output, size_t outlen, const char *s, const char *e);
static void set_symbol(const char *type, char *output, size_t outlen, const char *s, const char *e);

/* Determine whether a bare filename is OK - for LOAD FROM /something/or/other.unl ... etc */
static int  bare_filename_ok = 0;

/* Primary entry point - yyparse() */
#ifndef YYJLSSYACC
YYSTATIC int  yyparse(void);
static   int  yylex(void);
static   void yyerror(const char *s);
#endif /* YYJLSSYACC */

#ifndef lint
/* Prevent over-aggressive optimizers from eliminating ID string */
const char jlss_id_connecty_y[] = "@(#)$Id: connecty.c.std,v 2012.1 2012/08/05 18:33:54 jleffler Exp $";
#endif /* lint */

/* End of user defined code */
#line 1000 "/Users/jleffler/lib/jlssyypars"

/* Token list */
#define K_ACCESS 257
#define K_ALL 258
#define K_APPEND 259
#define K_AS 260
#define K_BASETABLES 261
#define K_BY 262
#define K_CHECK 263
#define K_COLUMNS 264
#define K_CONCURRENT 265
#define K_CONNECT 266
#define K_CONNECTION 267
#define K_CONNECTIONS 268
#define K_CONSTRAINTS 269
#define K_CREATE 270
#define K_CSV 271
#define K_CURRENT 272
#define K_DATABASES 273
#define K_DEFAULT 274
#define K_DELIMITER 275
#define K_DISCONNECT 276
#define K_EOR 277
#define K_ESCAPE 278
#define K_EXECUTE 279
#define K_FILE 280
#define K_FIXED 281
#define K_FIXSEP 282
#define K_FIXDEL 283
#define K_DB2 284
#define K_FOR 285
#define K_FORMAT 286
#define K_FRAGMENTS 287
#define K_FROM 288
#define K_FUNCTION 289
#define K_HELP 290
#define K_INDEXES 291
#define K_INFO 292
#define K_INSERT 293
#define K_LOAD 294
#define K_PASSWORD 295
#define K_PIPE 296
#define K_PRIVILEGES 297
#define K_PROCBODY 298
#define K_PROCEDURE 299
#define K_PROCEDURES 300
#define K_QUOTE 301
#define K_RECORDTAG 302
#define K_REFERENCES 303
#define K_RELOAD 304
#define K_ROLES 305
#define K_SELECT 306
#define K_SET 307
#define K_SKIP 308
#define K_STATUS 309
#define K_SYNONYMS 310
#define K_SYSTABLES 311
#define K_TABLES 312
#define K_TO 313
#define K_TRANSACTIONS 314
#define K_TRIGBODY 315
#define K_TRIGGERS 316
#define K_TRUSTED 317
#define K_UNLOAD 318
#define K_USER 319
#define K_USERS 320
#define K_USING 321
#define K_VIEWBODY 322
#define K_VIEWS 323
#define K_WCT 324
#define K_WHERE 325
#define K_WITH 326
#define C_AT 327
#define C_COLON 328
#define C_LPAREN 329
#define C_PERIOD 330
#define C_RPAREN 331
#define C_SEMICOLON 332
#define S_IDENTIFIER 333
#define S_DQSTRING 334
#define S_SQSTRING 335
#define S_ERROR 336
#define S_NUMBER 337

/* Define YYGLOBAL as static if YYDEBUGVAR, YYLVAL and YYVAL can be hidden */
#ifndef YYGLOBAL
#define YYGLOBAL
#endif	/* YYGLOBAL */

/* Define YYSTATIC as empty if all YACC variables must be visible */
#ifndef YYSTATIC
#define YYSTATIC static
#endif	/* YYSTATIC */

/* Define YYDEBUG if debugging to be compiled in */
#ifndef YYDEBUG
#define YYDEBUG 0 /* No debug */
#endif	/* YYDEBUG */

/* Define YYLVAL if yylval is to be renamed*/
#ifndef YYLVAL
#define YYLVAL yylval
#endif	/* YYLVAL */

/* Define YYVAL if yyval is to be renamed */
#ifndef YYVAL
#define YYVAL yyval
#endif	/* YYVAL */

/* Define YYDEBUGVAR if yydebug is to be renamed */
#ifndef YYDEBUGVAR
#define YYDEBUGVAR yydebug
#endif	/* YYDEBUGVAR */

/* Define YYPARSE if yyparse() is to be renamed */
#ifndef YYPARSE
#define YYPARSE yyparse
#endif	/* YYPARSE */

/* Define YYLEX if yylex() is to be renamed */
#ifndef YYLEX
#define YYLEX yylex
#endif	/* YYLEX */

/* Define YYSYNTAX if yyerror() is to be renamed (YYERROR is already used!) */
#ifndef YYSYNTAX
#define YYSYNTAX yyerror
#endif	/* YYSYNTAX */

/* Define YY_SC_PARSE as static if yyparse() is private */
#ifndef YY_SC_PARSE
#define YY_SC_PARSE extern
#endif	/* YY_SC_PARSE */

/* Define YY_SC_LEX as static if yylex() is private */
#ifndef YY_SC_LEX
#define YY_SC_LEX extern
#endif	/* YY_SC_SYNTAX */

/* Define YY_SC_SYNTAX as static if yyerror() is private */
#ifndef YY_SC_SYNTAX
#define YY_SC_SYNTAX extern
#endif	/* YY_SC_SYNTAX */

/* Declare yyparse(), yylex() and yyerror() */
YY_SC_PARSE int YYPARSE(void);
YY_SC_LEX int YYLEX(void);
YY_SC_SYNTAX void YYSYNTAX(const char *);

/* Define YYMAXDEPTH if you need an extra-deep stack */
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif

#ifndef YYSTYPE
#define YYSTYPE int
#endif
/* Define YYTOKS_ARRAY because yytoks array is produced */
#define YYTOKS_ARRAY 1
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0

#define YYERRCODE 256

YYSTATIC int    yyerrflag;		/* error recovery flag */
YYSTATIC int    yychar;			/* current input token number */
YYGLOBAL YYSTYPE YYLVAL;		/* Value of previous token */
YYGLOBAL YYSTYPE YYVAL;		/* Value of current token */
#ifndef YYDEBUG_UNUSED
YYGLOBAL int YYDEBUGVAR;		/* set to 1 to get debugging */
#endif /* YYDEBUG_UNUSED */

/* Start of user defined code */
#line 763 "connecty.y"


struct Keyword
{
    const char *keyword;
    int         token;
};

typedef struct Keyword Keyword;

/* keylist to be maintained in alphabetic order of keyword */

/**INDENT-OFF**/
static Keyword keylist[] =
{
    {   "ACCESS",           K_ACCESS        },
    {   "ALL",              K_ALL           },
    {   "APPEND",           K_APPEND        },
    {   "AS",               K_AS            },
    {   "BASETABLES",       K_BASETABLES    },
    {   "BY",               K_BY            },
    {   "CHECK",            K_CHECK         },
    {   "COLUMNS",          K_COLUMNS       },
    {   "CONCURRENT",       K_CONCURRENT    },
    {   "CONNECT",          K_CONNECT       },
    {   "CONNECTION",       K_CONNECTION    },
    {   "CONNECTIONS",      K_CONNECTIONS   },
    {   "CONSTRAINTS",      K_CONSTRAINTS   },
    {   "CREATE",           K_CREATE        },
    {   "CSV",              K_CSV           },
    {   "CURRENT",          K_CURRENT       },
    {   "DATABASES",        K_DATABASES     },
    {   "DB2",              K_DB2           },
    {   "DEFAULT",          K_DEFAULT       },
    {   "DELIMITER",        K_DELIMITER     },
    {   "DISCONNECT",       K_DISCONNECT    },
    {   "EOR",              K_EOR           },
    {   "ESCAPE",           K_ESCAPE        },
    {   "EXECUTE",          K_EXECUTE       },
    {   "FILE",             K_FILE          },
    {   "FIXDEL",           K_FIXDEL        },
    {   "FIXED",            K_FIXED         },
    {   "FIXSEP",           K_FIXSEP        },
    {   "FOR",              K_FOR           },
    {   "FORMAT",           K_FORMAT        },
    {   "FRAGMENTS",        K_FRAGMENTS     },
    {   "FROM",             K_FROM          },
    {   "FUNCTION",         K_FUNCTION      },
    {   "HELP",             K_HELP          },
    {   "INDEXES",          K_INDEXES       },
    {   "INFO",             K_INFO          },
    {   "INSERT",           K_INSERT        },
    {   "LOAD",             K_LOAD          },
    {   "PASSWORD",         K_PASSWORD      },
    {   "PIPE",             K_PIPE          },
    {   "PRIVILEGES",       K_PRIVILEGES    },
    {   "PROCBODY",         K_PROCBODY      },
    {   "PROCEDURE",        K_PROCEDURE     },
    {   "PROCEDURES",       K_PROCEDURES    },
    {   "QUOTE",            K_QUOTE         },
    {   "RECORDTAG",        K_RECORDTAG     },
    {   "REFERENCES",       K_REFERENCES    },
    {   "RELOAD",           K_RELOAD        },
    {   "ROLES",            K_ROLES         },
    {   "SELECT",           K_SELECT        },
    {   "SET",              K_SET           },
    {   "SKIP",             K_SKIP          },
    {   "STATUS",           K_STATUS        },
    {   "SYNONYMS",         K_SYNONYMS      },
    {   "SYSTABLES",        K_SYSTABLES     },
    {   "TABLES",           K_TABLES        },
    {   "TO",               K_TO            },
    {   "TRANSACTIONS",     K_TRANSACTIONS  },
    {   "TRIGBODY",         K_TRIGBODY      },
    {   "TRIGGERS",         K_TRIGGERS      },
    {   "UNLOAD",           K_UNLOAD        },
    {   "USER",             K_USER          },
    {   "USERS",            K_USERS         },
    {   "USING",            K_USING         },
    {   "VIEWBODY",         K_VIEWBODY      },
    {   "VIEWS",            K_VIEWS         },
    {   "WCT",              K_WCT           },
    {   "WHERE",            K_WHERE         },
    {   "WITH",             K_WITH          },
/**INDENT-ON**/
};

#define DIM(x)  (sizeof(x)/sizeof(*(x)))
#define CONST_CAST(type, value) ((type)(value))

#define MAX_LEXTOKENLENGTH  (2*SQL_NAMELEN+3)

static int kw_compare(const void *p1, const void *p2)
{
    const Keyword *k1 = (Keyword *)p1;  /*=C++=*/
    const Keyword *k2 = (Keyword *)p2;  /*=C++=*/
    return(cistrcmp(k1->keyword, k2->keyword));
}

static void set_token(char *output, size_t outlen, const char *s, const char *e)
{
    size_t space = e - s + 1;
    if (outlen < space)
        space = outlen;
    nstrcpy(output, space, s);
}

static void set_symbol(const char *type, char *output, size_t outlen, const char *s, const char *e)
{
    size_t space = e - s + 1;
    if (*output != '\0')
    {
        err_remark("repeat specification of %s (old = %s, new = %.*s); using new value.\n",
                   type, output,  (int)(e - s), s);
    }
    if (outlen < space)
    {
        char ebuff[256];
        err_remark("overflow detected: %s is far too long (requested %d, %d available: %s)\n",
                    type, (int)space, (int)outlen, strdotfill(ebuff, sizeof(ebuff), s, space));
        space = outlen;
    }
    nstrcpy(output, space, s);
}

/* Duplicate a quote-enclosed string */
/* s points to opening quote; e to closing quote */
static char *strcdup(const char *s, const char *e)
{
    char *base = (char *)MALLOC(--e - ++s + 1);     /*=C++=*/
    nstrcpy(base, e - s + 1, s);
    return(base);
}

static void set_database(ConnInfo *c, const char *s, const char *e)
{
    c->database = strcdup(s, e);
}

static void set_connection(ConnInfo *c, const char *s, const char *e)
{
    c->connname = strcdup(s, e);
}

static void set_username(ConnInfo *c, const char *s, const char *e)
{
    c->username = strcdup(s, e);
}

static void set_password(ConnInfo *c, const char *s, const char *e)
{
    c->password = strcdup(s, e);
}

static void set_string(const char *type, char *output, size_t outlen, const char *s, const char *e)
{
    set_symbol(type, output, outlen, s + 1, e - 1);
}

static void set_statement(char *stmt_str)
{
#ifndef NDEBUG
    /* If assert is enabled, verify that keylist is in sorted order */
    static int done_once = 0;
    size_t i;
    if (done_once == 0)
    {
        for (i = 0; i < DIM(keylist) - 1; i++)
            assert(kw_compare(&keylist[i], &keylist[i+1]) < 0);
        done_once = 1;
    }
#endif /* NDEBUG */
    c_token = stmt_str;
}

static const char *const_skipblanks(const char *str)
{
    while (*str != '\0' && isspace(*str))
        str++;
    return(str);
}

static const char *const_skipnonblanks(const char *str)
{
    while (*str != '\0' && !isspace(*str))
        str++;
    return(str);
}

static const char *scan_for_filename(const char *str, const char **end)
{
    const char *start = const_skipblanks(str);
    if (*start == '\'' || *start == '"')
        start = sqltoken(start, end);
    else
        *end = const_skipnonblanks(start);
    return(start);
}

static int yylex(void)
{
    char        buffer[MAX_LEXTOKENLENGTH];
    const char *start;

    if (c_token == 0)
        abort();

    if (bare_filename_ok)
        start = scan_for_filename(c_token, &c_token);
    else
        start = sqltoken(c_token, &c_token);

    yylval.start = CONST_CAST(char *, start);
    yylval.end = CONST_CAST(char *, c_token);
    if (*start == '\0')
    {
        yylval.toktype = 0;
        return yylval.toktype;
    }
    set_token(buffer, sizeof(buffer), start, c_token);
#ifdef YYDEBUG
    if (YYDEBUGVAR > 1)
        printf("yylex(): token = %s\n", buffer);
#endif /* YYDEBUG */

    /* printf("yylex(): token = %s\n", buffer); */
    if (isalpha((unsigned char)buffer[0]) || buffer[0] == '_')
    {
        Keyword  kw;
        Keyword *p;
        kw.keyword = buffer;
        p = (Keyword *)bsearch(&kw, keylist, DIM(keylist), sizeof(Keyword),
                                kw_compare);    /*=C++=*/
        if (p == 0)
            yylval.toktype = S_IDENTIFIER;
        else
            yylval.toktype = p->token;
    }
    else if (buffer[0] == '\'')
    {
        yylval.toktype = S_SQSTRING;
    }
    else if (buffer[0] == '"')
    {
        yylval.toktype = S_DQSTRING;
    }
    else if (isdigit((unsigned char)buffer[0]))
    {
        yylval.toktype = S_NUMBER;
    }
    else if (buffer[0] == '.' && isdigit((unsigned char)buffer[1]))
    {
        yylval.toktype = S_NUMBER;
    }
    else if (buffer[0] == ';')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_SEMICOLON;
    }
    else if (buffer[0] == '.')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_PERIOD;
    }
    else if (buffer[0] == '@')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_AT;
    }
    else if (buffer[0] == '(')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_LPAREN;
    }
    else if (buffer[0] == ')')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_RPAREN;
    }
    else if (buffer[0] == ':')
    {
        assert(buffer[1] == '\0');
        yylval.toktype = C_COLON;
    }
    else
    {
        yylval.toktype = S_ERROR;
    }
    return yylval.toktype;
}

static void yyerror(const char *s)
{
    /* Do nothing here -- it will be reported elsewhere */
}

/* conninfo_setempty - initialize a ConnInfo structure to all zeroes */
/* NB: must be here for standalone testing, but must also be */
/*     accessible to code in conninfo.c */
void conninfo_setempty(ConnInfo *c)
{
    static const ConnInfo zero_conninfo = { 0 };
    *c = zero_conninfo;
}

static void infoinfo_setempty(InfoInfo *i)
{
    static const InfoInfo zero_infoinfo = { "" };
    *i = zero_infoinfo;
}

static void loadinfo_setempty(LoadInfo *l)
{
    static const LoadInfo zero_loadinfo = { "" };
    *l = zero_loadinfo;
}

#ifndef YYDEBUG
#define ENTER_EXIT(dir, fun)    ((void)0)
#else
#define ENTER_EXIT(dir, fun)    enter_exit(dir, fun)
static void enter_exit(const char *dir, const char *fun)
{
    if (YYDEBUGVAR > 0)
        printf("%s %s()\n", dir, fun);
}
#endif /* YYDEBUG */

static StmtType parse_sqlstmt(char *str, InfoInfo *p_info, ConnInfo *p_conn, LoadInfo *p_load)
{
    info = p_info;
    conn = p_conn;
    load = p_load;
    stmt_type = STMT_NONE;
    loadinfo_setempty(load);
    infoinfo_setempty(info);
    conninfo_setempty(conn);
    set_statement(str);
    ENTER_EXIT("-->>", "yyparse");
    (void)yyparse();
    ENTER_EXIT("<<--", "yyparse");
    set_statement(0);
    return stmt_type;
}

StmtType parse_connstmt(char *str, ConnInfo *p_conn)
{
    InfoInfo l_info;
    LoadInfo l_load;
    return(parse_sqlstmt(str, &l_info, p_conn, &l_load));
}

StmtType parse_infostmt(char *str, InfoInfo *p_info)
{
    ConnInfo l_conn;
    LoadInfo l_load;
    return(parse_sqlstmt(str, p_info, &l_conn, &l_load));
}

StmtType parse_loadstmt(char *str, LoadInfo *p_load)
{
    ConnInfo l_conn;
    InfoInfo l_info;
    return(parse_sqlstmt(str, &l_info, &l_conn, p_load));
}

int set_yydebug(int newval)
{
#if !YYJLSSYACC && !YYBYACC && !YYBISON
    extern int YYDEBUGVAR;
#endif /* YYJLSSYACC */
    int oldval = YYDEBUGVAR;
    YYDEBUGVAR = newval;
    return(oldval);
}

#ifdef TEST

static void pr_conninfo(ConnInfo *p_conn)
{
    printf("Database = %s, Connection = %s, Username = %s, "
        "Password = %s WCT = %d, ConnType = %d, MODE ANSI = %d\n",
        p_conn->database, p_conn->connname, p_conn->username, p_conn->password,
        p_conn->wct, p_conn->ctype, p_conn->mode_ansi);
}

static void pr_loadinfo(const char *what, LoadInfo *c_load)
{
    printf("%s statement: file = %s, delim = %s, quote = %s, escape = %s, eor = <%s> stmt = %s\n",
            what, c_load->file, c_load->delim, c_load->quote, c_load->escape, c_load->eor, c_load->stmt);
}

static void pr_where(InfoInfo *p_info)
{
    if (p_info->wh_start)
    {
        int len = p_info->wh_end - p_info->wh_start;
        printf(" WHERE (%.*s)", len, p_info->wh_start);
    }
    putchar('\n');
}

static void pr_otherinfo(const char *what, InfoInfo *p_info)
{
    printf("INFO %s", what);
    pr_where(p_info);
}

static void pr_tableinfo(InfoInfo *p_info)
{
    printf("-- for table <<");
    if (p_info->dbase[0])
        printf("%s", p_info->dbase);
    if (p_info->server[0])
        printf("@%s", p_info->server);
    if (p_info->dbase[0])
        putchar(':');
    if (p_info->owner[0])
        printf("%s.", p_info->owner);
    printf("%s", p_info->table);
    puts(">>");
    pr_where(p_info);
}

int main(int argc, char **argv)
{
    char buffer[2048];
    StmtType n;
    InfoInfo c_info;
    ConnInfo c_conn;
    LoadInfo c_load;
    int debug_level = 1;

    err_setarg0(argv[0]);
    if (argc == 2)
        debug_level = atoi(argv[1]);
    else if (argc > 2)
        err_usage("[debug-level]\n  0 => no Yacc debugging\n  1 => Yacc debugging\n  2 => Lexical analyzer too");

    set_yydebug(1);
    fputs("SQL? ", stdout);
    fflush(stdout);
    while (fgets(buffer, sizeof(buffer), stdin) != 0)
    {
        buffer[strlen(buffer) - 1] = '\0';
        printf("Input: << %s >>\n", buffer);
        n = parse_sqlstmt(buffer, &c_info, &c_conn, &c_load);
        printf("Output: %d ", (int)n);
        switch (n)
        {
        case STMT_SETCONN:
            printf("SET CONNECTION\n");
            pr_conninfo(&c_conn);
            break;
        case STMT_CONNECT:
            printf("CONNECT\n");
            pr_conninfo(&c_conn);
            break;
        case STMT_DISCONN:
            printf("DISCONNECT\n");
            pr_conninfo(&c_conn);
            break;
        case STMT_SETOTHER:
            printf("<<%s>>\nA SET statement, but not a SET CONNECTION statement!\n", buffer);
            break;
        case STMT_DISCONNERR:
            printf("<<%s>>\nSyntax error in DISCONNECT!\n", buffer);
            break;
        case STMT_CONNECTERR:
            printf("<<%s>>\nSyntax error in CONNECT!\n", buffer);
            break;
        case STMT_SETCONNERR:
            printf("<<%s>>\nStarts SET CONNECTION but invalid syntax\n", buffer);
            break;

        case STMT_ERROR:
            printf("<<%s>>\nGeneric error -- unrecognized statement!\n", buffer);
            break;

        case STMT_LOAD:
            pr_loadinfo("LOAD", &c_load);
            break;
        case STMT_RELOAD:
            pr_loadinfo("RELOAD", &c_load);
            break;
        case STMT_UNLOAD:
            pr_loadinfo("UNLOAD", &c_load);
            break;

        case INFO_USERS:
            pr_otherinfo("USERS", &c_info);
            break;
        case INFO_ROLES:
            pr_otherinfo("ROLES", &c_info);
            break;
        case INFO_SYSTABLES:
            pr_otherinfo("SYSTABLES", &c_info);
            break;
        case INFO_VIEWS:
            pr_otherinfo("VIEWS", &c_info);
            break;
        case INFO_SYNONYMS:
            pr_otherinfo("SYNONYMS", &c_info);
            break;
        case INFO_BASETABLES:
            pr_otherinfo("BASETABLES", &c_info);
            break;
        case INFO_PROCEDURES:
            pr_otherinfo("PROCEDURES", &c_info);
            break;
        case INFO_TABLES:
            pr_otherinfo("TABLES", &c_info);
            break;

        case INFO_CONSTR_CHECK:
            printf("INFO CHECK CONSTRAINTS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_COLUMNS:
            printf("INFO COLUMNS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_INDEXES:
            printf("INFO INDEXES\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_ACCESS:       /* aka PRIVILEGES */
            printf("INFO ACCESS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_REFS_BY:
            printf("INFO REFERENCES BY\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_REFS_TO:
            printf("INFO REFERENCES TO\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_TRIGGERS:
            printf("INFO TRIGGERS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_STATUS:
            printf("INFO STATUS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_PROCBODY:
            printf("INFO PROCBODY:\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_FRAGMENTS:
            printf("INFO FRAGMENTS\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_TRIGBODY:
            printf("INFO TRIGBODY:\n");
            pr_tableinfo(&c_info);
            break;
        case INFO_VIEWBODY:
            printf("INFO VIEWBODY:\n");
            pr_tableinfo(&c_info);
            break;

        case INFO_HELP:
            printf("INFO HELP\n");
            printf("** Implemented options:\n"
                    "-- INFO ACCESS (aka INFO PRIVILEGES)\n"
                    "-- INFO BASETABLES\n"
                    "-- INFO CHECK CONSTRAINTS FOR table\n"
                    "-- INFO COLUMNS FOR table\n"
                    "-- INFO CONNECTIONS\n"
                    "-- INFO DATABASES\n"
                    "-- INFO FRAGMENTS FOR table\n"
                    "-- INFO HELP\n"
                    "-- INFO PROCBODY FOR procname\n"
                    "-- INFO PROCEDURES\n"
                    "-- INFO REFERENCES BY table\n"
                    "-- INFO REFERENCES TO table\n"
                    "-- INFO ROLES\n"
                    "-- INFO STATUS FOR table\n"
                    "-- INFO SYNONYMS\n"
                    "-- INFO SYSTABLES\n"
                    "-- INFO TABLES\n"
                    "-- INFO TRIGBODY FOR trigger\n"
                    "-- INFO TRIGGERS FOR table\n"
                    "-- INFO USERS\n"
                    "-- INFO VIEWBODY FOR view\n"
                    "-- INFO VIEWS\n"
                    );
            break;

        case INFO_CONNECTIONS:
            printf("INFO CONNECTIONS\n");
            break;

        case INFO_DATABASES:
            printf("INFO DATABASES\n");
            break;

        case STMT_RELOADERR:
            printf("<<%s>>\nSyntax error in UNLOAD statement\n", buffer);
            break;

        case STMT_UNLOADERR:
            printf("<<%s>>\nSyntax error in UNLOAD statement\n", buffer);
            break;

        case STMT_LOADERR:
            printf("<<%s>>\nSyntax error in LOAD statement\n", buffer);
            break;

        case INFO_ERROR:
            printf("<<%s>>\nSyntax error in INFO statement\n", buffer);
            break;

        case STMT_NONE:
            printf("Empty String - ignored\n");
            break;

        default:
            printf("Unknown statement type %d in switch statement.\n", n);
            assert(0);
            break;
        }

        fputs("SQL? ", stdout);
        fflush(stdout);
    }
    puts("");
    return 0;
}

#endif /* TEST */

/* End of user defined code */
#line 2000 "/Users/jleffler/lib/jlssyypars"

/* Exception table */
YYSTATIC short yyexca[] = {
	  -1,    1,
	   0,   -1,
	  -2,    0,
	  -1,   35,
	 296,  180,
	  -2,  166,
	  -1,  252,
	 327,  226,
	 328,  226,
	 330,  231,
	  -2,  229,
	  -1,  253,
	 330,  126,
	  -2,  230,
	  -1,  289,
	 330,  231,
	  -2,  229
};

#if YYDEBUG
typedef struct { char *t_name; int t_val; } yytoktype;
YYSTATIC yytoktype yytoks[] =
{
	{ "K_ACCESS", K_ACCESS },
	{ "K_ALL", K_ALL },
	{ "K_APPEND", K_APPEND },
	{ "K_AS", K_AS },
	{ "K_BASETABLES", K_BASETABLES },
	{ "K_BY", K_BY },
	{ "K_CHECK", K_CHECK },
	{ "K_COLUMNS", K_COLUMNS },
	{ "K_CONCURRENT", K_CONCURRENT },
	{ "K_CONNECT", K_CONNECT },
	{ "K_CONNECTION", K_CONNECTION },
	{ "K_CONNECTIONS", K_CONNECTIONS },
	{ "K_CONSTRAINTS", K_CONSTRAINTS },
	{ "K_CREATE", K_CREATE },
	{ "K_CSV", K_CSV },
	{ "K_CURRENT", K_CURRENT },
	{ "K_DATABASES", K_DATABASES },
	{ "K_DEFAULT", K_DEFAULT },
	{ "K_DELIMITER", K_DELIMITER },
	{ "K_DISCONNECT", K_DISCONNECT },
	{ "K_EOR", K_EOR },
	{ "K_ESCAPE", K_ESCAPE },
	{ "K_EXECUTE", K_EXECUTE },
	{ "K_FILE", K_FILE },
	{ "K_FIXED", K_FIXED },
	{ "K_FIXSEP", K_FIXSEP },
	{ "K_FIXDEL", K_FIXDEL },
	{ "K_DB2", K_DB2 },
	{ "K_FOR", K_FOR },
	{ "K_FORMAT", K_FORMAT },
	{ "K_FRAGMENTS", K_FRAGMENTS },
	{ "K_FROM", K_FROM },
	{ "K_FUNCTION", K_FUNCTION },
	{ "K_HELP", K_HELP },
	{ "K_INDEXES", K_INDEXES },
	{ "K_INFO", K_INFO },
	{ "K_INSERT", K_INSERT },
	{ "K_LOAD", K_LOAD },
	{ "K_PASSWORD", K_PASSWORD },
	{ "K_PIPE", K_PIPE },
	{ "K_PRIVILEGES", K_PRIVILEGES },
	{ "K_PROCBODY", K_PROCBODY },
	{ "K_PROCEDURE", K_PROCEDURE },
	{ "K_PROCEDURES", K_PROCEDURES },
	{ "K_QUOTE", K_QUOTE },
	{ "K_RECORDTAG", K_RECORDTAG },
	{ "K_REFERENCES", K_REFERENCES },
	{ "K_RELOAD", K_RELOAD },
	{ "K_ROLES", K_ROLES },
	{ "K_SELECT", K_SELECT },
	{ "K_SET", K_SET },
	{ "K_SKIP", K_SKIP },
	{ "K_STATUS", K_STATUS },
	{ "K_SYNONYMS", K_SYNONYMS },
	{ "K_SYSTABLES", K_SYSTABLES },
	{ "K_TABLES", K_TABLES },
	{ "K_TO", K_TO },
	{ "K_TRANSACTIONS", K_TRANSACTIONS },
	{ "K_TRIGBODY", K_TRIGBODY },
	{ "K_TRIGGERS", K_TRIGGERS },
	{ "K_TRUSTED", K_TRUSTED },
	{ "K_UNLOAD", K_UNLOAD },
	{ "K_USER", K_USER },
	{ "K_USERS", K_USERS },
	{ "K_USING", K_USING },
	{ "K_VIEWBODY", K_VIEWBODY },
	{ "K_VIEWS", K_VIEWS },
	{ "K_WCT", K_WCT },
	{ "K_WHERE", K_WHERE },
	{ "K_WITH", K_WITH },
	{ "C_AT", C_AT },
	{ "C_COLON", C_COLON },
	{ "C_LPAREN", C_LPAREN },
	{ "C_PERIOD", C_PERIOD },
	{ "C_RPAREN", C_RPAREN },
	{ "C_SEMICOLON", C_SEMICOLON },
	{ "S_IDENTIFIER", S_IDENTIFIER },
	{ "S_DQSTRING", S_DQSTRING },
	{ "S_SQSTRING", S_SQSTRING },
	{ "S_ERROR", S_ERROR },
	{ "S_NUMBER", S_NUMBER },
	{ "-unknown-", -1 } /* end search */
};
#endif	/* YYDEBUG */

#if YYDEBUG
YYSTATIC char *yyreds[] =
{
	"-no such reduction-",
	"statement :  opt_semicolon",
	"statement :  connect opt_semicolon",
	"statement :  disconnect opt_semicolon",
	"statement :  setconnect opt_semicolon",
	"statement :  setother opt_semicolon",
	"statement :  info opt_semicolon",
	"statement :  load",
	"statement :  unload",
	"statement :  reload",
	"statement :  K_UNLOAD error token_list",
	"statement :  K_RELOAD error token_list",
	"statement :  K_LOAD error token_list",
	"statement :  K_DISCONNECT error token_list",
	"statement :  K_CONNECT error token_list",
	"statement :  K_SET K_CONNECTION error token_list",
	"statement :  K_INFO error token_list",
	"statement :  error",
	"opt_semicolon : ",
	"opt_semicolon :  C_SEMICOLON",
	"connect :  K_CONNECT K_TO K_DEFAULT opt_wct",
	"connect :  K_CONNECT dbenv opt_conn opt_user opt_wct opt_trusted",
	"dbenv :  K_TO string",
	"opt_wct : ",
	"opt_wct :  K_WCT",
	"opt_wct :  K_WITH K_CONCURRENT K_TRANSACTIONS",
	"opt_trusted : ",
	"opt_trusted :  K_TRUSTED",
	"opt_conn : ",
	"opt_conn :  K_AS string",
	"opt_user : ",
	"opt_user :  username password",
	"username :  K_USER string",
	"password :  using_or_password string",
	"using_or_password :  K_USING",
	"using_or_password :  K_PASSWORD",
	"disconnect :  K_DISCONNECT K_CURRENT",
	"disconnect :  K_DISCONNECT K_ALL",
	"disconnect :  K_DISCONNECT K_DEFAULT",
	"disconnect :  K_DISCONNECT string",
	"setconnect :  K_SET conntype",
	"setother :  K_SET error token_list",
	"token_list : ",
	"token_list :  token_list token",
	"token :  keyword",
	"token :  non_keyword",
	"keyword :  K_ACCESS",
	"keyword :  K_ALL",
	"keyword :  K_APPEND",
	"keyword :  K_AS",
	"keyword :  K_BASETABLES",
	"keyword :  K_BY",
	"keyword :  K_CHECK",
	"keyword :  K_COLUMNS",
	"keyword :  K_CONCURRENT",
	"keyword :  K_CONNECT",
	"keyword :  K_CONNECTION",
	"keyword :  K_CONNECTIONS",
	"keyword :  K_CONSTRAINTS",
	"keyword :  K_CREATE",
	"keyword :  K_CSV",
	"keyword :  K_CURRENT",
	"keyword :  K_DATABASES",
	"keyword :  K_DB2",
	"keyword :  K_DEFAULT",
	"keyword :  K_DELIMITER",
	"keyword :  K_DISCONNECT",
	"keyword :  K_EOR",
	"keyword :  K_ESCAPE",
	"keyword :  K_EXECUTE",
	"keyword :  K_FILE",
	"keyword :  K_FIXDEL",
	"keyword :  K_FIXED",
	"keyword :  K_FIXSEP",
	"keyword :  K_FOR",
	"keyword :  K_FORMAT",
	"keyword :  K_FRAGMENTS",
	"keyword :  K_FROM",
	"keyword :  K_FUNCTION",
	"keyword :  K_HELP",
	"keyword :  K_INDEXES",
	"keyword :  K_INFO",
	"keyword :  K_INSERT",
	"keyword :  K_LOAD",
	"keyword :  K_PASSWORD",
	"keyword :  K_PIPE",
	"keyword :  K_PRIVILEGES",
	"keyword :  K_PROCBODY",
	"keyword :  K_PROCEDURE",
	"keyword :  K_PROCEDURES",
	"keyword :  K_QUOTE",
	"keyword :  K_RECORDTAG",
	"keyword :  K_REFERENCES",
	"keyword :  K_RELOAD",
	"keyword :  K_ROLES",
	"keyword :  K_SELECT",
	"keyword :  K_SET",
	"keyword :  K_SKIP",
	"keyword :  K_STATUS",
	"keyword :  K_SYNONYMS",
	"keyword :  K_SYSTABLES",
	"keyword :  K_TABLES",
	"keyword :  K_TO",
	"keyword :  K_TRANSACTIONS",
	"keyword :  K_TRIGBODY",
	"keyword :  K_TRIGGERS",
	"keyword :  K_TRUSTED",
	"keyword :  K_UNLOAD",
	"keyword :  K_USER",
	"keyword :  K_USERS",
	"keyword :  K_USING",
	"keyword :  K_VIEWBODY",
	"keyword :  K_VIEWS",
	"keyword :  K_WCT",
	"keyword :  K_WHERE",
	"keyword :  K_WITH",
	"non_keyword :  C_AT",
	"non_keyword :  C_COLON",
	"non_keyword :  C_PERIOD",
	"non_keyword :  C_LPAREN",
	"non_keyword :  C_RPAREN",
	"non_keyword :  S_ERROR",
	"non_keyword :  string",
	"non_keyword :  S_IDENTIFIER",
	"non_keyword :  S_NUMBER",
	"string :  S_SQSTRING",
	"string :  S_DQSTRING",
	"conntype :  K_CONNECTION string",
	"conntype :  K_CONNECTION K_DEFAULT",
	"load :  K_LOAD K_FROM opt_file_pipe string load_opt_list K_INSERT",
	"opt_file_pipe : ",
	"opt_file_pipe :  K_FILE",
	"opt_file_pipe :  K_PIPE",
	"load_opt_list : ",
	"load_opt_list :  load_opt_list load_opt",
	"load_opt :  common_opt",
	"load_opt :  skip",
	"common_opt :  delimiter",
	"common_opt :  quote",
	"common_opt :  escape",
	"common_opt :  eor",
	"common_opt :  format",
	"format :  K_FORMAT string",
	"format :  K_FORMAT fmt_kwd",
	"fmt_kwd :  K_CSV",
	"fmt_kwd :  K_DB2",
	"fmt_kwd :  K_FIXDEL",
	"fmt_kwd :  K_FIXED",
	"fmt_kwd :  K_FIXSEP",
	"fmt_kwd :  K_QUOTE",
	"fmt_kwd :  K_SELECT",
	"fmt_kwd :  K_UNLOAD",
	"skip :  K_SKIP number",
	"number :  S_NUMBER",
	"reload :  K_RELOAD K_FROM opt_file_pipe string reload_opt_list K_INSERT",
	"reload_opt_list : ",
	"reload_opt_list :  reload_opt_list reload_opt",
	"reload_opt :  load_opt",
	"unload :  K_UNLOAD unload_dst unload_opt_list unload_src",
	"unload_dst :  unload_file",
	"unload_dst :  unload_pipe",
	"unload_file :  to_file",
	"unload_file :  create_file",
	"unload_file :  append_file",
	"unload_pipe :  to_pipe",
	"to_file :  K_TO opt_file filename",
	"opt_file : ",
	"opt_file :  K_FILE",
	"filename :  string",
	"create_file :  K_CREATE opt_file filename",
	"append_file :  K_APPEND opt_to opt_file filename",
	"to_pipe :  opt_to K_PIPE shell_command",
	"shell_command :  filename",
	"unload_opt_list : ",
	"unload_opt_list :  unload_opt_list unload_opt",
	"unload_opt :  common_opt",
	"unload_opt :  xmlrectag",
	"unload_src :  K_SELECT",
	"unload_src :  K_EXECUTE proc_or_func",
	"opt_to : ",
	"opt_to :  K_TO",
	"proc_or_func :  K_PROCEDURE",
	"proc_or_func :  K_FUNCTION",
	"xmlrectag :  K_RECORDTAG string",
	"delimiter :  K_DELIMITER string",
	"quote :  K_QUOTE string",
	"eor :  K_EOR string",
	"escape :  K_ESCAPE string",
	"info :  info_unqualified",
	"info :  info_qualified",
	"info_unqualified :  K_INFO K_TABLES opt_where",
	"info_unqualified :  K_INFO K_SYSTABLES opt_where",
	"info_unqualified :  K_INFO K_BASETABLES opt_where",
	"info_unqualified :  K_INFO K_VIEWS opt_where",
	"info_unqualified :  K_INFO K_SYNONYMS opt_where",
	"info_unqualified :  K_INFO K_PROCEDURES opt_where",
	"info_unqualified :  K_INFO K_DATABASES",
	"info_unqualified :  K_INFO K_CONNECTIONS",
	"info_unqualified :  K_INFO K_USERS opt_where",
	"info_unqualified :  K_INFO K_ROLES opt_where",
	"info_unqualified :  K_INFO K_HELP",
	"opt_where : ",
	"opt_where :  K_WHERE token_list",
	"info_qualified :  K_INFO K_COLUMNS for_objname",
	"info_qualified :  K_INFO K_INDEXES for_objname",
	"info_qualified :  K_INFO K_ACCESS for_objname",
	"info_qualified :  K_INFO K_PRIVILEGES for_objname",
	"info_qualified :  K_INFO K_STATUS for_objname",
	"info_qualified :  K_INFO K_PROCBODY for_objname",
	"info_qualified :  K_INFO K_FRAGMENTS for_objname",
	"info_qualified :  K_INFO K_REFERENCES to_table",
	"info_qualified :  K_INFO K_REFERENCES by_table",
	"info_qualified :  K_INFO K_VIEWBODY for_objname",
	"info_qualified :  K_INFO K_TRIGGERS for_objname",
	"info_qualified :  K_INFO K_TRIGBODY for_objname",
	"info_qualified :  K_INFO K_CHECK K_CONSTRAINTS for_objname",
	"for_objname :  K_FOR object_name",
	"to_table :  K_TO object_name",
	"by_table :  K_BY object_name",
	"identifier_or_keyword :  S_IDENTIFIER",
	"identifier_or_keyword :  keyword",
	"object_name :  object",
	"object_name :  obj_dbase object",
	"obj_dbase :  obj_dbname opt_server C_COLON",
	"opt_server : ",
	"opt_server :  C_AT identifier_or_keyword",
	"obj_dbname :  identifier_or_keyword",
	"object :  obj_name",
	"object :  obj_owner C_PERIOD obj_name",
	"obj_name :  identifier_or_keyword",
	"obj_name :  S_DQSTRING",
	"obj_owner :  identifier_or_keyword",
	"obj_owner :  string"
};
#endif	/* YYDEBUG */

#define YYNPROD 233
#define YYLAST 692

YYSTATIC short yyact[] = {
   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,
   143,   144,   145,   146,   147,   148,   149,   151,   152,   153,
   154,   155,   156,   157,   159,   160,   158,   150,   161,   162,
   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,
   173,   174,   175,   176,   177,   178,   179,   180,   181,   182,
   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,
   193,   194,   195,   196,   197,   198,   199,   200,   201,   202,
   203,   204,   206,   205,   207,   311,   210,    49,    48,   208,
   211,   133,   134,   135,   136,   137,   138,   139,   140,   141,
   142,   143,   144,   145,   146,   147,   148,   149,   151,   152,
   153,   154,   155,   156,   157,   159,   160,   158,   150,   161,
   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,
   172,   173,   174,   175,   176,   177,   178,   179,   180,   181,
   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,
   192,   193,   194,   195,   196,   197,   198,   199,   200,   201,
   202,    49,    48,    19,   308,   290,   292,   255,   253,    48,
   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,
   143,   144,   145,   146,   147,   148,   149,   151,   152,   153,
   154,   155,   156,   157,   159,   160,   158,   150,   161,   162,
   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,
   173,   174,   175,   176,   177,   178,   179,   180,   181,   182,
   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,
   193,   194,   195,   196,   197,   198,   199,   200,   201,   202,
   238,   242,   239,   106,   303,   301,   255,   307,   133,   134,
   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,
   145,   146,   147,   148,   149,   151,   152,   153,   154,   155,
   156,   157,   159,   160,   158,   150,   161,   162,   163,   164,
   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,
   175,   176,   177,   178,   179,   180,   181,   182,   183,   184,
   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,
   195,   196,   197,   198,   199,   200,   201,   202,    56,    70,
    96,   286,    50,    59,   255,    79,    68,    43,   270,    45,
    64,    86,   100,    87,   262,    63,   252,   125,   273,   274,
   272,   271,   249,    44,   261,    46,   131,   285,    90,    74,
   102,    41,    67,    69,   115,   295,   129,    39,   275,    71,
    73,    83,    62,   276,    91,    75,    18,    66,   281,    99,
   247,    72,    61,    58,    57,   277,    15,    78,    77,    51,
    49,    48,    65,    42,    76,    60,    14,    27,   124,    40,
    37,    49,    48,   237,   246,   229,    55,   224,    89,   227,
   226,    36,    17,   296,    13,    49,    48,    53,   228,    38,
    49,    48,    82,   250,    12,   299,   209,    16,   114,   291,
   251,   248,   224,   225,   227,   226,   123,   122,    11,    21,
   298,    47,   224,   228,   227,   226,   215,    20,   260,   217,
   293,    93,    19,   228,    35,   213,     2,    85,   225,    84,
    22,    23,    24,    25,    26,   298,   233,    34,   225,   223,
    33,    32,   256,   214,    31,    30,    29,    80,    97,   212,
   101,   256,   256,    81,    28,   294,   279,   105,   310,   269,
   231,   222,   221,   234,   220,   216,   219,   218,   116,   117,
   118,   119,   120,   121,   297,   126,   127,   128,   232,   230,
   280,   230,   132,   130,   230,    54,   235,    88,   284,    92,
   236,    94,   283,   241,   302,   240,   243,    98,    95,   257,
   258,    52,    10,   103,   104,     9,     8,     7,     6,     5,
     4,     3,   254,     1,     0,     0,   107,   108,   109,   110,
   111,   254,   254,   112,   113,     0,     0,     0,   259,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   244,     0,
     0,     0,     0,     0,   245,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   289,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   256,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   288,
     0,     0,     0,     0,     0,     0,     0,   306,   278,   309,
     0,     0,     0,   305,   282,     0,   300,   256,     0,   256,
   263,   264,   265,   266,   267,   268,     0,     0,     0,   230,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   287,
     0,     0,     0,     0,     0,   254,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   304
};

YYSTATIC short yypact[] = {
   100, -1000, -1000,  -179,  -179,  -179,  -179,  -179, -1000, -1000,
 -1000,   121,    91,    85,    61,    56,   130,    52, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000,    71,    71,     8,    27, -1000,
    58, -1000,    58, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000,    36,    99,    66, -1000, -1000, -1000,   -92,   -92,   -92,
   -92,   -92,   -92, -1000, -1000,   -92,   -92, -1000,    59,    59,
    59,    59,    59,    59,    59,    65,    59,    59,    59,    77,
  -257,   147,  -183, -1000,  -183,    71, -1000,  -183,  -257,  -183,
 -1000, -1000,  -257,  -183,  -257,  -257,   -94, -1000,   -88,  -183,
 -1000, -1000, -1000,  -257,  -257, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000,  -176, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000,  -176,  -176, -1000, -1000, -1000,    59,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000,    35, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000,  -183,  -183,  -183,  -183,  -183,    47, -1000,
 -1000, -1000,  -183, -1000, -1000, -1000, -1000, -1000, -1000,    93,
   -94,    16,  -183, -1000,  -257,  -257, -1000, -1000,  -176, -1000,
  -175,  -171, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,   137,
   112,   -79,   -83, -1000,  -183, -1000, -1000, -1000, -1000, -1000,
   -97,  -174,   -19, -1000, -1000, -1000, -1000, -1000,  -262, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000
};

YYSTATIC short yypgo[] = {
     0,   523,   436,   521,   520,   519,   518,   517,   516,   515,
   512,   457,   383,   511,   507,   505,   504,   406,   503,   502,
   498,   495,   493,   336,   492,   388,   490,   345,   393,   484,
   477,   476,   474,   472,   471,   469,   468,   466,   465,   464,
   463,   459,   456,   455,   454,   451,   450,   447,   402,   385,
   399,   446,   435,   429,   428,   427,   419,   467,   408,   417,
   416,   384,   326,   360,   411,   410,   409,   332,   403
};

YYSTATIC short yyr1[] = {
     0,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,
     3,     3,    13,    12,    12,    12,    16,    16,    14,    14,
    15,    15,    18,    19,    20,    20,     4,     4,     4,     4,
     5,     6,    11,    11,    22,    22,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    23,    23,    23,    23,
    23,    23,    23,    23,    23,    23,    24,    24,    24,    24,
    24,    24,    24,    24,    24,    17,    17,    21,    21,     8,
    25,    25,    25,    26,    26,    27,    27,    28,    28,    28,
    28,    28,    34,    34,    35,    35,    35,    35,    35,    35,
    35,    35,    29,    36,    10,    37,    37,    38,     9,    39,
    39,    42,    42,    42,    43,    44,    48,    48,    49,    45,
    46,    47,    51,    40,    40,    52,    52,    41,    41,    50,
    50,    54,    54,    53,    30,    31,    33,    32,     7,     7,
    55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
    55,    57,    57,    56,    56,    56,    56,    56,    56,    56,
    56,    56,    56,    56,    56,    56,    58,    59,    60,    62,
    62,    61,    61,    64,    66,    66,    65,    63,    63,    67,
    67,    68,    68
};

YYSTATIC short yyr2[] = {
     0,     1,     2,     2,     2,     2,     2,     1,     1,     1,
     3,     3,     3,     3,     3,     4,     3,     1,     0,     1,
     4,     6,     2,     0,     1,     3,     0,     1,     0,     2,
     0,     2,     2,     2,     1,     1,     2,     2,     2,     2,
     2,     3,     0,     2,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     2,     2,     6,
     0,     1,     1,     0,     2,     1,     1,     1,     1,     1,
     1,     1,     2,     2,     1,     1,     1,     1,     1,     1,
     1,     1,     2,     1,     6,     0,     2,     1,     4,     1,
     1,     1,     1,     1,     1,     3,     0,     1,     1,     3,
     4,     3,     1,     0,     2,     1,     1,     1,     2,     0,
     1,     1,     1,     2,     2,     2,     2,     2,     1,     1,
     3,     3,     3,     3,     3,     3,     2,     2,     3,     3,
     2,     0,     2,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     4,     2,     2,     2,     1,
     1,     1,     2,     3,     0,     2,     1,     1,     3,     1,
     1,     1,     1
};

YYSTATIC short yychk[] = {
 -1000,    -1,    -2,    -3,    -4,    -5,    -6,    -7,    -8,    -9,
   -10,   318,   304,   294,   276,   266,   307,   292,   256,   332,
   -55,   -56,    -2,    -2,    -2,    -2,    -2,   256,   -39,   -42,
   -43,   -44,   -45,   -46,   -47,   313,   270,   259,   -50,   256,
   288,   256,   288,   256,   272,   258,   274,   -17,   335,   334,
   256,   313,   -13,   267,   -21,   256,   256,   312,   311,   261,
   323,   310,   300,   273,   268,   320,   305,   290,   264,   291,
   257,   297,   309,   298,   287,   303,   322,   316,   315,   263,
   -11,   -40,   -48,   280,   -48,   -50,   313,   296,   -11,   -25,
   280,   296,   -11,   -25,   -11,   -11,   274,   -17,   -14,   260,
   256,   -17,   274,   -11,   -11,   -57,   325,   -57,   -57,   -57,
   -57,   -57,   -57,   -57,   -58,   285,   -58,   -58,   -58,   -58,
   -58,   -58,   -59,   -60,   313,   262,   -58,   -58,   -58,   269,
   -22,   -23,   -24,   257,   258,   259,   260,   261,   262,   263,
   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,
   284,   274,   275,   276,   277,   278,   279,   280,   283,   281,
   282,   285,   286,   287,   288,   289,   290,   291,   292,   293,
   294,   295,   296,   297,   298,   299,   300,   301,   302,   303,
   304,   305,   306,   307,   308,   309,   310,   311,   312,   313,
   314,   315,   316,   317,   318,   319,   320,   321,   322,   323,
   324,   325,   326,   327,   328,   330,   329,   331,   336,   -17,
   333,   337,   -41,   -52,   306,   279,   -28,   -53,   -30,   -31,
   -32,   -33,   -34,   302,   275,   301,   278,   277,   286,   -49,
   -17,   -49,   -48,   -51,   -49,   -17,   -17,   -12,   324,   326,
   -15,   -18,   319,   -17,   -11,   -11,   -61,   -63,   -64,   -67,
   -68,   -65,   -62,   334,   -17,   333,   -23,   -61,   -61,   -58,
   -54,   299,   289,   -17,   -17,   -17,   -17,   -17,   -17,   -35,
   271,   284,   283,   281,   282,   301,   306,   318,   -49,   -37,
   -26,   265,   -12,   -19,   -20,   321,   295,   -17,   -63,   -62,
   330,   -66,   327,   293,   -38,   -27,   -28,   -29,   308,   293,
   -27,   314,   -16,   317,   -17,   -67,   -62,   334,   328,   -62,
   -36,   337
};

YYSTATIC short yydef[] = {
    18,    -2,     1,    18,    18,    18,    18,    18,     7,     8,
     9,   179,     0,     0,     0,     0,     0,     0,    17,    19,
   188,   189,     2,     3,     4,     5,     6,    42,   173,   159,
   160,   161,   162,   163,   164,    -2,   166,   179,     0,    42,
   130,    42,   130,    42,    36,    37,    38,    39,   125,   126,
    42,     0,    28,     0,    40,    42,    42,   201,   201,   201,
   201,   201,   201,   196,   197,   201,   201,   200,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    10,     0,     0,   167,     0,   166,   180,     0,    11,     0,
   131,   132,    12,     0,    13,    14,    23,    22,    30,     0,
    42,   127,   128,    41,    16,   190,    42,   191,   192,   193,
   194,   195,   198,   199,   203,     0,   204,   205,   206,   207,
   208,   209,   210,   211,     0,     0,   212,   213,   214,     0,
    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
    73,    74,    75,    76,    77,    78,    79,    80,    81,    82,
    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,
   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,
   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,
   123,   124,   158,   174,   177,     0,   175,   176,   137,   138,
   139,   140,   141,     0,     0,     0,     0,     0,     0,   165,
   168,   169,     0,   171,   172,   155,   133,    20,    24,     0,
    23,     0,     0,    29,    15,   202,   216,   221,     0,   227,
     0,   224,    -2,    -2,   232,   219,   220,   217,   218,   215,
   178,   181,   182,   183,   184,   185,   187,   186,   142,   143,
   144,   145,   146,   147,   148,   149,   150,   151,   170,     0,
     0,     0,    26,    31,     0,    34,    35,    32,   222,    -2,
     0,     0,     0,   154,   156,   157,   135,   136,     0,   129,
   134,    25,    21,    27,    33,   228,   229,   230,   223,   225,
   152,   153
};

#line 1 "/Users/jleffler/lib/jlssyypars"
/*
@(#)File:            $RCSfile: connecty.c.std,v $
@(#)Version:         $Revision: 2012.1 $
@(#)Last changed:    $Date: 2012/08/05 18:33:54 $
@(#)Purpose:         Skeleton parser driver for JLSS YACC
@(#)Author:          J Leffler
*/

/*TABSTOP=4*/

#include <stdio.h>

/* yacc user known macros and defines */
#ifdef YYERROR_UNUSED
#define YYERROR		error YYERROR_UNUSED defined but YYERROR used!
#else
#define YYERROR		goto yyerrlab
#endif /* YYERROR_UNUSED */

#define YYACCEPT	return(0)
#define YYABORT		return(1)

#ifdef YYBACKUP_UNUSED
#define YYBACKUP	error YYBACKUP_UNUSED defined but YYBACKUP used!
#else
#define YYBACKUP(newtoken, newvalue)\
{\
	if (yychar >= 0 || yyr2[yytmp] != 1)\
	{\
		YYSYNTAX("syntax error - cannot backup");\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	YYLVAL = newvalue;\
	yystate = *yyps;\
	goto yybackup;\
}
#endif /* YYBACKUP_UNUSED */

#define YYRECOVERING()	(!!yyerrflag)
#define YYFLAG		(-1000)

/*
** global variables used by the parser
** YYSTATIC is defined before the tables are produced.
*/
YYSTATIC YYSTYPE  yyv[YYMAXDEPTH];	/* value stack */
YYSTATIC int      yys[YYMAXDEPTH];	/* state stack */
YYSTATIC YYSTYPE *yypv;				/* top of value stack */
YYSTATIC int     *yyps;				/* top of state stack */
YYSTATIC int      yystate;			/* current state */

#if YYDEBUG
/*
** if debugging, look up token value in list of value vs.
** name pairs.  0 and negative (-1) are special values.
** Note: linear search is used since time is not a real
** consideration while debugging.
*/
#define YY_ISPRINT(x)	((x) >= 32 && (x) < 127)	/* ASCII */
static char *yy_token(int token)
{
	static char buff[7];
	char	*cp;
	int		 i;

	if (token < 0)
		cp = "-none-";
	else if (token == 0)
		cp = "-EOF-";
	else if (token < YYERRCODE && YY_ISPRINT(token))
	{
		i = 0;
		buff[i++] = '\'';
		if (token == '\\' || token == '\'')
			buff[i++] = '\\';
		buff[i++] = token;
		buff[i++] = '\'';
		buff[i]   = '\0';
		cp = buff;
	}
	else if (token < YYERRCODE)
	{
		sprintf(buff, "'0x%02X'", token);
		cp = buff;
	}
	else
	{
		for (i = 0; yytoks[i].t_val >= 0; i++)
			if (yytoks[i].t_val == token)
				break;
		cp = yytoks[i].t_name;
	}
	return(cp);
}
#endif /* YYDEBUG */

#if YYDEBUG
#define YY_GETTOKEN()	yy_gettoken()
static int yy_gettoken(void)
{
	if (yychar < 0)
	{
		if ((yychar = YYLEX()) < 0)
			yychar = 0;
		if (YYDEBUGVAR)
			fprintf(stderr, "Received token %s\n", yy_token(yychar));
	}
	return(yychar);
}
#else /* YYDEBUG == 0 */
#define YY_GETTOKEN()	((yychar<0 && (yychar=YYLEX())<0) ? yychar=0 : yychar)
#endif /* YYDEBUG */

/*
** YYPARSE - return 0 if worked, 1 if syntax error not recovered from
*/
YY_SC_PARSE int YYPARSE(void)
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */
	register int      yy_len;
	int               yytmp;	/* Number of action being reduced */

	/* Initialize externals - yyparse may be called more than once */
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yyerrflag = 0;
	yychar = -1;

	goto yystack;
	{
		register YYSTYPE *yy_pv;/* top of value stack */
		register int   *yy_ps;	/* top of state stack */
		register int    yy_state;	/* current state */
		register int    yy_n;	/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
#ifndef YYBACKUP_UNUSED
yybackup:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
#if YYDEBUG
		fprintf(stderr, "Backup to state %d, token %s\n", yystate, yy_token(yychar));
#endif /* YYDEBUG */
		goto yy_newstate;
#endif /* YYBACKUP_UNUSED */

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/* top of for (;;) loop while no reductions done */
yy_stack:
#if YYDEBUG
		if (YYDEBUGVAR)
			fprintf(stderr, "State %d, token %s\n", yy_state, yy_token(yychar));
#endif	/* YYDEBUG */
		/* put a state and value onto the stacks */
		if (++yy_ps >= &yys[YYMAXDEPTH])	/* room on stack? */
		{
			YYSYNTAX("yacc stack overflow");
			YYABORT;
		}
		*yy_ps = yy_state;
		*++yy_pv = YYVAL;

		/* we have a new state - find out what to do */
yy_newstate:
		if ((yy_n = yypact[yy_state]) <= YYFLAG)
			goto yydefault;		/* simple state -- no lookahead necessary */
		YY_GETTOKEN();
		if (((yy_n += yychar) < 0) || (yy_n >= YYLAST))
			goto yydefault;
		if (yychk[yy_n = yyact[yy_n]] == yychar)	/* valid shift */
		{
			yychar = -1;
			YYVAL = YYLVAL;
			yy_state = yy_n;
			if (yyerrflag > 0)
				yyerrflag--;
			goto yy_stack;
		}

yydefault:
		if ((yy_n = yydef[yy_state]) == -2)
		{
			YY_GETTOKEN();
			/* look through exception table */
			{
				register short *yyxi = yyexca;

				while ((*yyxi != -1) || (yyxi[1] != yy_state))
				{
					yyxi += 2;
				}
				while ((*(yyxi += 2) >= 0) && (*yyxi != yychar))
					;
				if ((yy_n = yyxi[1]) < 0)
					YYACCEPT;
			}
		}

		/* check for syntax error */
		if (yy_n == 0)			/* have an error */
		{
			/* no worry about speed here! */
			switch (yyerrflag)
			{
			case 0:			/* new error */
				YYSYNTAX("syntax error");
				goto skip_init;
#ifndef YYERROR_UNUSED
		yyerrlab:
#endif /* YYERROR_UNUSED */
				/*
				** YYERROR -- user generated syntax type error
				** get globals into registers.
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
		skip_init:
			case 1:
			case 2:			/* incompletely recovered error */
				/* try again... */
				yyerrflag = 3;
				/* find state where "error" is a legal shift action */
				while (yy_ps >= yys)
				{
					yy_n = yypact[*yy_ps] + YYERRCODE;
					if (yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)
					{
						/* simulate shift of "error" */
						yy_state = yyact[yy_n];
						goto yy_stack;
					}
					/* current state has no shift on "error", pop stack */
#if YYDEBUG
#define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if (YYDEBUGVAR)
						fprintf(stderr, _POP_, *yy_ps, yy_ps[-1]);
#undef _POP_
#endif	/* YYDEBUG */
					yy_ps--;
					yy_pv--;
				}
				/*
				** There is no state on stack with "error" as a valid shift.
				** Give up.
				*/
				YYABORT;
			case 3:			/* no shift yet; eat a token */
#if YYDEBUG
				if (YYDEBUGVAR)
					fprintf(stderr, "Error recovery discards token %s\n",
							yy_token(yychar));
#endif	/* YYDEBUG */
				if (yychar == 0)	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}
		/* End of ERROR RECOVERY */

		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/

#if YYDEBUG
		/*
		** If debugging, print the string that is the user's
		** specification of the reduction which is just about to be done.
		*/
		if (YYDEBUGVAR)
			fprintf(stderr, "Reduce by (%d) \"%s\"\n", yy_n, yyreds[yy_n]);
#endif	/* YYDEBUG */

		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		*/
		yy_len = yyr2[yy_n];
		YYVAL  = (yy_pv -= yy_len)[1];	/* $$ = $1 */
		yy_state = yypgo[yy_n = yyr1[yy_n]] + *(yy_ps -= yy_len) + 1;
		if (yy_state >= YYLAST || yychk[yy_state = yyact[yy_state]] != -yy_n)
			yy_state = yyact[yypgo[yy_n]];

		/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}

	/* Actions supplied by user are placed in this switch */
	switch (yytmp)
	{
		/* Start of actions */

	case 1:
#line 200 "connecty.y"
		{ stmt_type = STMT_NONE; }
		break;

	case 2:
#line 202 "connecty.y"
		{ stmt_type = STMT_CONNECT; }
		break;

	case 3:
#line 204 "connecty.y"
		{ stmt_type = STMT_DISCONN; }
		break;

	case 4:
#line 206 "connecty.y"
		{ stmt_type = STMT_SETCONN; }
		break;

	case 5:
#line 208 "connecty.y"
		{ stmt_type = STMT_SETOTHER; }
		break;

	case 6:
#line 210 "connecty.y"
		{ stmt_type = (StmtType) yypvt[-1].toktype; /*=C++=*/ }
		break;

	case 7:
#line 212 "connecty.y"
		{ stmt_type = STMT_LOAD; YYACCEPT; }
		break;

	case 8:
#line 214 "connecty.y"
		{ stmt_type = STMT_UNLOAD; YYACCEPT; }
		break;

	case 9:
#line 216 "connecty.y"
		{ stmt_type = STMT_RELOAD; YYACCEPT; }
		break;

	case 10:
#line 218 "connecty.y"
		{ stmt_type = STMT_UNLOADERR; }
		break;

	case 11:
#line 220 "connecty.y"
		{ stmt_type = STMT_RELOADERR; }
		break;

	case 12:
#line 222 "connecty.y"
		{ stmt_type = STMT_LOADERR; }
		break;

	case 13:
#line 224 "connecty.y"
		{ stmt_type = STMT_DISCONNERR; }
		break;

	case 14:
#line 226 "connecty.y"
		{ stmt_type = STMT_CONNECTERR; }
		break;

	case 15:
#line 228 "connecty.y"
		{ stmt_type = STMT_SETCONNERR; }
		break;

	case 16:
#line 230 "connecty.y"
		{ stmt_type = INFO_ERROR; }
		break;

	case 17:
#line 232 "connecty.y"
		{
            if (stmt_type >= INFO_BASE)
                stmt_type = INFO_ERROR;
            else if (stmt_type > STMT_NONE)
                stmt_type = (StmtType)(-stmt_type); /*=C++=*/
            else
                stmt_type = STMT_ERROR;
        }
		break;

	case 20:
#line 249 "connecty.y"
		{ conn->ctype = CONN_DEFAULT; }
		break;

	case 22:
#line 255 "connecty.y"
		{ set_database(conn, yypvt[-0].start, yypvt[-0].end); }
		break;

	case 23:
#line 260 "connecty.y"
		{ conn->wct = 0; }
		break;

	case 24:
#line 262 "connecty.y"
		{ conn->wct = 1; }
		break;

	case 25:
#line 264 "connecty.y"
		{ conn->wct = 1; }
		break;

	case 26:
#line 269 "connecty.y"
		{ conn->trusted = 0; }
		break;

	case 27:
#line 271 "connecty.y"
		{ conn->trusted = 1; }
		break;

	case 28:
#line 276 "connecty.y"
		{ conn->ctype = CONN_NONE; }
		break;

	case 29:
#line 278 "connecty.y"
		{ conn->ctype = CONN_STRING;
          set_connection(conn, yypvt[-0].start, yypvt[-0].end);
        }
		break;

	case 30:
#line 285 "connecty.y"
		{ conn->username = 0; conn->password= 0; }
		break;

	case 32:
#line 291 "connecty.y"
		{ set_username(conn, yypvt[-0].start, yypvt[-0].end); }
		break;

	case 33:
#line 296 "connecty.y"
		{ set_password(conn, yypvt[-0].start, yypvt[-0].end); }
		break;

	case 36:
#line 306 "connecty.y"
		{ conn->ctype = CONN_CURRENT; }
		break;

	case 37:
#line 308 "connecty.y"
		{ conn->ctype = CONN_ALL; }
		break;

	case 38:
#line 310 "connecty.y"
		{ conn->ctype = CONN_DEFAULT; }
		break;

	case 39:
#line 312 "connecty.y"
		{ conn->ctype = CONN_STRING;
          set_connection(conn, yypvt[-0].start, yypvt[-0].end);
        }
		break;

	case 41:
#line 323 "connecty.y"
		{ yyerrok; }
		break;

	case 43:
#line 329 "connecty.y"
		{ YYVAL = yypvt[-0]; }
		break;

	case 127:
#line 429 "connecty.y"
		{ conn->ctype = CONN_STRING;
          set_connection(conn, yypvt[-0].start, yypvt[-0].end);
        }
		break;

	case 128:
#line 433 "connecty.y"
		{ conn->ctype = CONN_DEFAULT; }
		break;

	case 129:
#line 438 "connecty.y"
		{
            set_string("load file", load->file, sizeof(load->file), yypvt[-2].start, yypvt[-2].end);
            load->stmt = yypvt[-0].start;
        }
		break;

	case 130:
#line 446 "connecty.y"
		{ load->pipe_or_file = LD_FILE; }
		break;

	case 131:
#line 448 "connecty.y"
		{ load->pipe_or_file = LD_FILE; }
		break;

	case 132:
#line 450 "connecty.y"
		{ load->pipe_or_file = LD_PIPE; }
		break;

	case 142:
#line 473 "connecty.y"
		{ set_string("format name", load->format, sizeof(load->format), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 143:
#line 475 "connecty.y"
		{ set_symbol("format name", load->format, sizeof(load->format), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 152:
#line 492 "connecty.y"
		{ set_symbol("skip", load->skip, sizeof(load->skip), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 154:
#line 501 "connecty.y"
		{
            set_string("reload file", load->file, sizeof(load->file), yypvt[-2].start, yypvt[-2].end);
            load->stmt = yypvt[-0].start;
        }
		break;

	case 159:
#line 537 "connecty.y"
		{ load->pipe_or_file = LD_FILE; }
		break;

	case 160:
#line 539 "connecty.y"
		{ load->pipe_or_file = LD_PIPE; }
		break;

	case 165:
#line 554 "connecty.y"
		{ load->mode = FM_CREATE; }
		break;

	case 168:
#line 564 "connecty.y"
		{ set_string("unload file", load->file, sizeof(load->file), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 169:
#line 569 "connecty.y"
		{ load->mode = FM_CREATE; }
		break;

	case 170:
#line 574 "connecty.y"
		{ load->mode = FM_APPEND; }
		break;

	case 171:
#line 579 "connecty.y"
		{ load->pipe_or_file = LD_PIPE; }
		break;

	case 177:
#line 599 "connecty.y"
		{ load->stmt = yypvt[-0].start; }
		break;

	case 178:
#line 601 "connecty.y"
		{ load->stmt = yypvt[-1].start; }
		break;

	case 183:
#line 616 "connecty.y"
		{ set_string("XML record tag", load->xmltag, sizeof(load->xmltag), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 184:
#line 621 "connecty.y"
		{ set_string("delimiter", load->delim, sizeof(load->delim), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 185:
#line 626 "connecty.y"
		{ set_string("quote", load->quote, sizeof(load->quote), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 186:
#line 631 "connecty.y"
		{ set_string("eor", load->eor, sizeof(load->eor), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 187:
#line 636 "connecty.y"
		{ set_string("escape", load->escape, sizeof(load->escape), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 190:
#line 646 "connecty.y"
		{ YYVAL.toktype = INFO_TABLES; }
		break;

	case 191:
#line 648 "connecty.y"
		{ YYVAL.toktype = INFO_SYSTABLES; }
		break;

	case 192:
#line 650 "connecty.y"
		{ YYVAL.toktype = INFO_BASETABLES; }
		break;

	case 193:
#line 652 "connecty.y"
		{ YYVAL.toktype = INFO_VIEWS; }
		break;

	case 194:
#line 654 "connecty.y"
		{ YYVAL.toktype = INFO_SYNONYMS; }
		break;

	case 195:
#line 656 "connecty.y"
		{ YYVAL.toktype = INFO_PROCEDURES; }
		break;

	case 196:
#line 658 "connecty.y"
		{ YYVAL.toktype = INFO_DATABASES; }
		break;

	case 197:
#line 660 "connecty.y"
		{ YYVAL.toktype = INFO_CONNECTIONS; }
		break;

	case 198:
#line 662 "connecty.y"
		{ YYVAL.toktype = INFO_USERS; }
		break;

	case 199:
#line 664 "connecty.y"
		{ YYVAL.toktype = INFO_ROLES; }
		break;

	case 200:
#line 666 "connecty.y"
		{ YYVAL.toktype = INFO_HELP; }
		break;

	case 202:
#line 672 "connecty.y"
		{ info->wh_start = yypvt[-1].end; info->wh_end = yypvt[-0].end; }
		break;

	case 203:
#line 677 "connecty.y"
		{ YYVAL.toktype = INFO_COLUMNS; }
		break;

	case 204:
#line 679 "connecty.y"
		{ YYVAL.toktype = INFO_INDEXES; }
		break;

	case 205:
#line 681 "connecty.y"
		{ YYVAL.toktype = INFO_ACCESS; }
		break;

	case 206:
#line 683 "connecty.y"
		{ YYVAL.toktype = INFO_ACCESS; }
		break;

	case 207:
#line 685 "connecty.y"
		{ YYVAL.toktype = INFO_STATUS; }
		break;

	case 208:
#line 687 "connecty.y"
		{ YYVAL.toktype = INFO_PROCBODY; }
		break;

	case 209:
#line 689 "connecty.y"
		{ YYVAL.toktype = INFO_FRAGMENTS; }
		break;

	case 210:
#line 691 "connecty.y"
		{ YYVAL.toktype = INFO_REFS_TO; }
		break;

	case 211:
#line 693 "connecty.y"
		{ YYVAL.toktype = INFO_REFS_BY; }
		break;

	case 212:
#line 695 "connecty.y"
		{ YYVAL.toktype = INFO_VIEWBODY; }
		break;

	case 213:
#line 697 "connecty.y"
		{ YYVAL.toktype = INFO_TRIGGERS; }
		break;

	case 214:
#line 699 "connecty.y"
		{ YYVAL.toktype = INFO_TRIGBODY; }
		break;

	case 215:
#line 701 "connecty.y"
		{ YYVAL.toktype = INFO_CONSTR_CHECK; }
		break;

	case 225:
#line 733 "connecty.y"
		{ set_symbol("dbserver", info->server, sizeof(info->server), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 226:
#line 738 "connecty.y"
		{ set_symbol("database", info->dbase, sizeof(info->dbase), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 227:
#line 743 "connecty.y"
		{ set_symbol("table", info->table, sizeof(info->table), yypvt[-0].start, yypvt[-0].end); }
		break;

	case 228:
#line 745 "connecty.y"
		{
            /* Must preserve quotes or no-quotes around */
            /* owner to work with MODE ANSI databases!! */
            set_symbol("owner", info->owner, sizeof(info->owner), yypvt[-2].start, yypvt[-2].end);
            set_symbol("table", info->table, sizeof(info->table), yypvt[-0].start, yypvt[-0].end);
        }
		break;
		/* End of actions */
#line 314 "/Users/jleffler/lib/jlssyypars"

	}
	goto yystack;				/* reset registers in driver code */
}
