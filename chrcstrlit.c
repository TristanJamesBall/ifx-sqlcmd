/*
@(#)File:           $RCSfile: chrcstrlit.c,v $
@(#)Version:        $Revision: 1.7 $
@(#)Last changed:   $Date: 2016/07/08 01:17:53 $
@(#)Purpose:        Convert character to corresponding C Character Literal
@(#)Author:         J Leffler
@(#)Copyright:      (C) JLSS 2001,2003,2005,2007,2015-16
@(#)Product:        SQLCMD Version 90.02 (2016-07-28)
*/

/*TABSTOP=4*/

#include "cchrstrlit.h"

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#if !defined(lint)
/* Prevent over-aggressive optimizers from eliminating ID string */
extern const char jlss_id_chrcstrlit_c[];
const char jlss_id_chrcstrlit_c[] = "@(#)$Id: chrcstrlit.c,v 1.7 2016/07/08 01:17:53 jleffler Exp $";
#endif /* lint */

/*
** Does not generate hex character constants.
** Always generates triple-digit octal constants.
** Always generates escapes in preference to octal.
** Escape question mark to ensure no trigraphs are generated by repetitive use.
** Handling of 0x80..0xFF is locale-dependent (might be octal, might be literal).
*/

void chr_cstrlit(unsigned char u, char *buffer, size_t buflen)
{
    if (buflen < 2)
        *buffer = '\0';
    else if (isprint(u) && u != '\'' && u != '\"' && u != '\\' && u != '\?')
        sprintf(buffer, "%c", u);
    else if (buflen < 3)
        *buffer = '\0';
    else
    {
        switch (u)
        {
        case '\a':  strcpy(buffer, "\\a"); break;
        case '\b':  strcpy(buffer, "\\b"); break;
        case '\f':  strcpy(buffer, "\\f"); break;
        case '\n':  strcpy(buffer, "\\n"); break;
        case '\r':  strcpy(buffer, "\\r"); break;
        case '\t':  strcpy(buffer, "\\t"); break;
        case '\v':  strcpy(buffer, "\\v"); break;
        case '\\':  strcpy(buffer, "\\\\"); break;
        case '\'':  strcpy(buffer, "\\'"); break;
        case '\"':  strcpy(buffer, "\\\""); break;
        case '\?':  strcpy(buffer, "\\\?"); break;
        default:
            if (buflen < 5)
                *buffer = '\0';
            else
                sprintf(buffer, "\\%03o", u);
            break;
        }
    }
}

#if defined(TEST)

#include <stdlib.h>

typedef struct Test
{
    unsigned char val;
    char str[5];
} Test;

#define DIM(x) (sizeof(x)/sizeof(*(x)))

static Test test[] =
{
    {   0x00,   "\\000" },
    {   0x01,   "\\001" },
    {   0x02,   "\\002" },
    {   0x06,   "\\006" },
    {   0x07,   "\\a"   },
    {   0x08,   "\\b"   },
    {   0x09,   "\\t"   },
    {   0x0A,   "\\n"   },
    {   0x0B,   "\\v"   },
    {   0x0C,   "\\f"   },
    {   0x0D,   "\\r"   },
    {   0x0E,   "\\016" },
    {   0x1B,   "\\033" },
    {   0x1F,   "\\037" },
    {   0x20,   " "     },
    {   0x22,   "\\\""  },
    {   0x27,   "\\'"   },
    {   0x3F,   "\\?"   },  /* Could also write "\\\?" to same effect */
    {   0x41,   "A"     },
    {   0x5C,   "\\\\"  },
    {   0x7A,   "z"     },
    {   0x7E,   "~"     },
    {   0x7F,   "\\177" },
    {   0x80,   "\\200" },
    {   0x9F,   "\\237" },
    {   0xA0,   "\\240" },
    {   0xAF,   "\\257" },
    {   0xFF,   "\\377" },
};

int main(void)
{
    size_t  i;
    char buffer1[8];
    char buffer2[8];
    int     rc = EXIT_SUCCESS;

    for (i = 0; i < DIM(test); i++)
    {
        chr_cstrlit(test[i].val, buffer1, sizeof(buffer1));
        sprintf(buffer2, "'%s'", buffer1);
        printf("Convert 0x%02X => %-6s ", test[i].val, buffer2);
        if (strcmp(test[i].str, buffer1) == 0)
            puts(" OK");
        else
        {
            printf(" ** FAIL ** (expected '%s')\n", test[i].str);
            rc = EXIT_FAILURE;
        }
    }
    puts((rc == EXIT_SUCCESS) ? "OK" : "** FAIL **");
    return(rc);
}

#endif /* TEST */
